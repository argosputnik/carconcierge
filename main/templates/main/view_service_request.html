{% extends 'main/base.html' %}
{% load static %}

{% block title %}Service Request #{{ service_request.id }}{% endblock %}

{# Use main_class block to apply padding class to the main element #}
{% block main_class %}main-padded-top{% endblock %}

{% block content %}
<div class="container"> {# Use a container for centering and responsiveness #}
  <h2 class="mb-4 text-center">Service Request Details</h2> {# Added text-center for consistency #}

  <div class="d-flex justify-content-center gap-3 mb-4"> {# Increased bottom margin slightly for separation #}
    {% include 'main/_dashboard_buttons.html' %}
  </div>

  <div class="card mb-4"> {# Wrap details in a card for better visual structure #}
    <div class="card-header">Request Information</div>
    <div class="card-body">
      <dl class="row">
        <dt class="col-sm-3">Request ID</dt>
        <dd class="col-sm-9">{{ service_request.id }}</dd>

        <dt class="col-sm-3">Requested At</dt>
        <dd class="col-sm-9">{{ service_request.requested_at|date:"Y-m-d H:i" }}</dd> {# Corrected date format dash #}

        <dt class="col-sm-3">Pickup Location</dt>
        <dd class="col-sm-9">{{ service_request.pickup_location }}</dd>

        <dt class="col-sm-3">Dropoff Location</dt>
        <dd class="col-sm-9">{{ service_request.dropoff_location }}</dd>

        <dt class="col-sm-3">Status</dt>
        <dd class="col-sm-9">{{ service_request.status }}</dd>

        <dt class="col-sm-3">Assigned To</dt>
        <dd class="col-sm-9">
          {% if service_request.assigned_to %}
            {{ service_request.assigned_to.get_full_name|default:"Assigned User" }} {# Added default #}
          {% else %}
            <em>Unassigned</em>
          {% endif %}
        </dd>

        {% if service_request.description %}
          <dt class="col-sm-3">Description</dt>
          <dd class="col-sm-9">{{ service_request.description }}</dd>
        {% endif %}
      </dl>
    </div>
  </div>


  <div class="card mb-4"> {# Wrap map in a card #}
    <div class="card-header">Location Map</div>
    <div class="card-body">
      <div
        id="map"
        data-address="{{ service_request.pickup_location|escapejs }}" {# Use escapejs for data attributes containing potentially complex strings #}
        data-share="{{ service_request.share_location|yesno:'true,false' }}"
        data-status="{{ service_request.status }}"
        style="height:500px; border:1px solid #ccc;"
      ></div>
      {# Message element to show geocoding status #}
      <div id="map-message" class="alert alert-info mt-2" style="display:none;">Finding location...</div>
    </div>
  </div>


  <div class="mt-4 text-center"> {# Centered buttons #}
    {# Adjust the back link URL based on the user's role if needed #}
    {% if request.user.role == 'customer' %}
      <a href="{% url 'customer_dashboard' %}" class="btn btn-secondary me-2">
        ← Back to Dashboard
      </a>
    {% elif request.user.role == 'concierge' %}
      <a href="{% url 'concierge_dashboard' %}" class="btn btn-secondary me-2">
        ← Back to Dashboard
      </a>
    {% elif request.user.role == 'dealer' %}
      <a href="{% url 'dealer_dashboard' %}" class="btn btn-secondary me-2">
        ← Back to Dashboard
      </a>
    {% elif request.user.role == 'owner' %}
      <a href="{% url 'owner_dashboard' %}" class="btn btn-secondary me-2">
        ← Back to Dashboard
      </a>
    {% else %}
       {# Default back link if role is not explicitly handled #}
       <a href="{% url 'home' %}" class="btn btn-secondary me-2">
         ← Back
       </a>
    {% endif %}

    {# Check permission before showing edit button #}
    {% if request.user == service_request.customer or request.user.role == 'concierge' or request.user.role == 'dealer' or request.user.role == 'owner' %}
      <a href="{% url 'edit_service_request' service_request.id %}" class="btn btn-primary">
        Edit
      </a>
    {% endif %}
  </div>
</div>
{% endblock %} {# End of block content #}


{% block scripts %}
<script>
document.addEventListener("DOMContentLoaded", function() {
  const mapEl = document.getElementById("map");
  const messageEl = document.getElementById("map-message");
  if (!mapEl) return; // Exit if map element doesn't exist

  // Get data from attributes
  const address = mapEl.dataset.address; // Raw address string
  const share   = mapEl.dataset.share === "true";
  const status  = mapEl.dataset.status;
  const role    = "{{ request.user.role|escapejs }}"; // Role needs escaping for JS

  console.log("Pickup address from data attribute:", address);

  // 1) Initialize map with a basic world view
  const map = L.map("map").setView([0, 0], 2); // Start zoomed out
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: "© OpenStreetMap contributors",
    maxZoom: 19, // Optional: Set max zoom
  }).addTo(map);

  // Show the "Finding location..." message immediately
  messageEl.style.display = "block";

  // Function to geocode the address and update the map
  function geocodeAndUpdateMap() {
    if (!address || address.trim() === "") {
        console.warn("No pickup address provided or address is empty.");
        messageEl.textContent = "Pickup address is missing or empty.";
        messageEl.className = "alert alert-danger mt-2";
        messageEl.style.display = "block"; // Ensure it's visible
        return; // Stop if no address
    }

    // Clean up the address for geocoding (replace newlines, trim whitespace)
    const geocodingAddress = address.replace(/\n/g, ' ').trim();
    console.log("Attempting to geocode:", geocodingAddress);

    fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(geocodingAddress)}&limit=1`)
      .then(response => {
        if (!response.ok) {
          // Throw an error with status text for better debugging
          throw new Error(`Geocoding HTTP error! Status: ${response.status} ${response.statusText}`);
        }
        return response.json();
      })
      .then(data => {
        console.log("Geocoding results:", data);

        if (data && data.length > 0) {
          const lat = parseFloat(data[0].lat);
          const lon = parseFloat(data[0].lon);

          // Validate coordinates
          if (isNaN(lat) || isNaN(lon)) {
             console.error("Invalid coordinates received:", data[0]);
             throw new Error("Invalid coordinates received from geocoding service.");
          }

          console.log(`Geocoding successful. Coordinates: ${lat}, ${lon}`);

          // Update map view and add marker
          map.setView([lat, lon], 15); // Zoom level 15 for specific address
          L.marker([lat, lon])
           .addTo(map)
           .bindPopup(`<b>Pickup:</b><br>${address.replace(/\n/g, '<br>')}`) // Use original address, format newlines for popup
           .openPopup();

          // Hide the message element on success
          messageEl.style.display = "none";

        } else {
          // Handle case where geocoding service returns empty results
          console.warn("Geocoding found no results for:", geocodingAddress);
          messageEl.textContent = `Could not find location for: "${geocodingAddress}". Please verify the address details.`;
          messageEl.className = "alert alert-warning mt-2";
          messageEl.style.display = "block"; // Ensure message is visible
          // Keep the world/default map view if no results
        }
      })
      .catch(error => {
        // Handle fetch errors or errors thrown during processing
        console.error("Geocoding process error:", error);
        messageEl.textContent = `Error finding location: ${error.message}. Please try again later or check the address.`;
        messageEl.className = "alert alert-danger mt-2";
        messageEl.style.display = "block"; // Ensure message is visible
        // Keep the world/default map view on error
      });
  }

  // Invalidate map size and attempt geocoding shortly after map initializes
  // Use requestAnimationFrame to wait for the next repaint, then setTimeout
  requestAnimationFrame(() => {
      map.invalidateSize(); // Ensure map dimensions are correct
      setTimeout(geocodeAndUpdateMap, 150); // Short delay before geocoding
  });


  // 2) Live tracking when Delivery and shared (Ensure this part is complete)
  if (status === "Delivery" && share) {
    // Setup WebSocket connection
    const ws_scheme = window.location.protocol === "https:" ? "wss" : "ws";
    const socketUrl = ws_scheme + '://' + window.location.host +
                      '/ws/location/{{ service_request.id }}/';

    let socket;
    let conciergeLocationMarker = null; // Keep track of the marker locally

    function connectWebSocket() {
      console.log("Attempting to connect WebSocket:", socketUrl);
      socket = new WebSocket(socketUrl);

      socket.onopen = function(e) {
        console.log("WebSocket connected");
      };

      socket.onclose = function(e) {
        console.log(`WebSocket disconnected. Code: ${e.code}, Reason: ${e.reason}. Attempting to reconnect...`);
        conciergeLocationMarker = null; // Reset marker on disconnect
        // Attempt to reconnect after a delay
        setTimeout(connectWebSocket, 5000); // Reconnect every 5 seconds
      };

      socket.onerror = function(e) {
        console.error("WebSocket error:", e);
        // Don't explicitly close here, onclose will handle reconnect attempt
      };

      // Handle incoming WebSocket messages
      socket.onmessage = function(e) {
        try {
            const data = JSON.parse(e.data);
            console.log("WebSocket message received:", data);
            if (data.lat && data.lng) {
              const ll = [parseFloat(data.lat), parseFloat(data.lng)];

              if (isNaN(ll[0]) || isNaN(ll[1])) {
                  console.error("Invalid coordinates received via WebSocket:", data);
                  return;
              }

              if (!conciergeLocationMarker) { // Use local variable
                console.log("Creating concierge marker at:", ll);
                conciergeLocationMarker = L.marker(ll, {
                  icon: L.icon({
                    iconUrl: "{% static 'images/concierge-icon.png' %}", // Ensure this path is correct
                    iconSize:   [32, 32],
                    iconAnchor: [16, 32], // Anchor at bottom center
                    popupAnchor: [0, -32] // Popup above the icon
                  })
                })
                .addTo(map)
                .bindPopup("Concierge Location");

                // Optionally adjust map view if needed, e.g., fit bounds
                // if (address) { // Check if pickup marker exists
                //    const pickupLatLng = ... // get pickup marker latlng if stored
                //    map.fitBounds(L.latLngBounds(ll, pickupLatLng).pad(0.1));
                // } else {
                //    map.setView(ll, 15); // Or just center on concierge if no pickup
                // }

              } else {
                console.log("Updating concierge marker to:", ll);
                conciergeLocationMarker.setLatLng(ll);
              }
              // Optionally open popup on update: .openPopup();
            } else {
               console.warn("WebSocket message missing lat/lng:", data);
            }
        } catch (parseError) {
            console.error("Failed to parse WebSocket message:", e.data, parseError);
        }
      }; // End of onmessage
    } // End of connectWebSocket

    connectWebSocket(); // Initial connection

    // concierge → send coords via WebSocket
    if (role === "concierge" && navigator.geolocation) {
      console.log("Setting up geolocation watch for concierge");
      navigator.geolocation.watchPosition(pos => {
        const lat = pos.coords.latitude,
              lng = pos.coords.longitude;
        console.log(`Concierge location update: ${lat}, ${lng}`);
        // Send location via WebSocket if connected
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({ lat: lat, lng: lng }));
        } else {
           console.warn("WebSocket not open, cannot send location.");
        }
      },
      (geoError) => { // Handle geolocation errors
         console.error("Geolocation error:", geoError);
      },
      { enableHighAccuracy: true, maximumAge: 5000, timeout: 10000 }); // Options
    } // End of if (role === "concierge")

    // customer/dealer/owner → Initial location fetch (if needed, might be redundant if WS connects fast)
    // This fetches the *last known* location when the page loads
    // Consider if this is still necessary or if waiting for the first WS message is better
    /*
    fetch("{% url 'service_request_location' service_request.id %}", {
      credentials: "same-origin" // Important for session auth
    })
      .then(r => {
        if (!r.ok) throw new Error(`Initial location fetch failed: ${r.status}`);
        return r.json();
      })
      .then(data => {
        console.log("Initial location fetch result:", data);
        if (data.lat && data.lng && !conciergeLocationMarker) { // Only if WS hasn't created it yet
          const ll = [parseFloat(data.lat), parseFloat(data.lng)];
           if (!isNaN(ll[0]) && !isNaN(ll[1])) {
              console.log("Creating concierge marker from initial fetch:", ll);
              conciergeLocationMarker = L.marker(ll, {
                icon: L.icon({
                  iconUrl: "{% static 'images/concierge-icon.png' %}",
                  iconSize:   [32,32],
                  iconAnchor: [16,32],
                  popupAnchor: [0, -32]
                })
              })
              .addTo(map)
              .bindPopup("Concierge Location (Initial)");
              // Optionally adjust view if needed
           }
        }
      })
      .catch(error => {
         console.error("Error fetching initial location:", error);
      });
    */

  } else if (status !== "Delivery") {
    console.log("Location tracking is not active (Status is not Delivery).");
  } else if (!share) {
    console.log("Location sharing is not enabled for this request.");
  } // End of the if/else if chain for WebSocket logic

}); // End of DOMContentLoaded listener
</script>
{% endblock %} {# End of block scripts #}
